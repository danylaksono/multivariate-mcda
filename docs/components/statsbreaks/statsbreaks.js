!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).statsbreaks={})}(this,(function(e){"use strict";function t(e){return null!==e&&""!==e&&"boolean"!=typeof e&&isFinite(e)}function s(e,t){return[r(e[0],t),e.slice(1,-1).map((e=>function(e,t){const s=Math.pow(10,t),r=e*s*(1+Number.EPSILON);return Math.round(r)/s}(e,t))),n(e[e.length-1],t)].flat()}function r(e,t){const s=Math.pow(10,t),r=e*s*(1+Math.sign(e)*Number.EPSILON);return Math.floor(r)/s}function n(e,t){const s=Math.pow(10,t),r=e*s*(1-Math.sign(e)*Number.EPSILON);return Math.ceil(r)/s}function i(e,t){const s=((e=e.sort(((e,t)=>e-t))).length-1)*t,r=Math.floor(s),n=s-r;return void 0!==e[r+1]?e[r]+n*(e[r+1]-e[r]):e[r]}class l extends Error{constructor(){super("Values must be superior or equal to zero"),this.name="ValuesInferiorOrEqualToZeroError"}}class a extends Error{constructor(){super("Too few values for the given number of breaks"),this.name="TooFewValuesError"}}class o extends Error{constructor(){super("Unknown classification method"),this.name="UnknownMethodError"}}class u extends Error{constructor(e){super(e||"Invalid number of classes"),this.name="InvalidNumberOfClassesError"}}class h extends Error{constructor(e){super(e||"Invalid precision"),this.name="InvalidPrecisionError"}}function c(e){if(!t(e))throw new u("The 'nb' parameter must be a number");if(e=+e,!Number.isInteger(e))throw new u("The 'nb' parameter must be an integer");if(e<2)throw new u("The 'nb' parameter must be superior or equal to 2");return e}function f(e){if(null===e)return null;if(void 0===e)return 2;if(!t(e))throw new h("The 'precision' parameter must be a number");if(e=+e,!Number.isInteger(e))throw new h("The 'precision' parameter must be an integer");if(e<0)throw new h("The 'precision' parameter must be superior or equal to 0");return e}function m(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=f(r.precision),l=!0===r.minmax||null==r.minmax;if(6>e.length)throw new a;let o=[i(e,0),i(e,.05),i(e,.25),i(e,.5),i(e,.75),i(e,.95),i(e,1)];return null!==n&&(o=s(o,n)),l||(o=o.slice(1,-1)),o}function p(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=null!=r.nb?c(r.nb):5,l=f(r.precision),o=!0===r.minmax||null==r.minmax;if(n>e.length)throw new a;let u=[];const h=1/n;for(let t=0;t<=n;t++)u.push(i(e,h*t));return u=u.sort(((e,t)=>e-t)),null!==l&&(u=s(u,l)),o||(u=u.slice(1,-1)),u}function b(e){let s=1/0;for(let r=0,n=e.length;r<n;r++)t(e[r])&&e[r]<s&&(s=e[r]);return s}function d(e){let s=-1/0;for(let r=0,n=e.length;r<n;r++)t(e[r])&&e[r]>s&&(s=e[r]);return s}function _(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=null!=r.nb?c(r.nb):5,i=f(r.precision),l=!0===r.minmax||null==r.minmax;if(n>e.length)throw new a;let o=[b(e),d(e)];const u=(o[1]-o[0])/n;let h=o[0];for(let e=0;e<n-1;e++)o.push(h+u),h+=u;return o=o.sort(((e,t)=>e-t)),null!==i&&(o=s(o,i)),l||(o=o.slice(1,-1)),o}function k(e,r={}){e=e.filter((e=>t(e))).map((e=>+e)).sort((function(e,t){return e-t}));let n=null!=r.nb?c(r.nb):5,i=f(r.precision),l=!0===r.minmax||null==r.minmax;if(n>e.length)throw new a;if(n>[...new Set(e)].length)throw new a("Too few unique values for the given number of breaks");let o=function(e,t){const s=[],r=[],n=e.length;let i,l,a,o,u,h,c,f,m,p,b,d;for(i=0;i<n;i++){const e=[],n=[],a=0===i?1:0;for(l=0;l<t;l++)e.push(a),n.push(1/0);s.push(e),r.push(n)}for(u=0,o=0;o<n;o++){for(c=f=m=0,a=0;a<=o;a++)if(d=o-a,h=e[d],m++,c+=h,f+=h*h,u=f-c*c/m,b=d-1,b>-1)for(l=1;l<t;l++)p=u+r[b][l-1],r[o][l]>=p&&(s[o][l]=d+1,r[o][l]=p);s[o][0]=1,r[o][0]=u}return{lower_class_limits:s,variance_combinations:r}}(e,n),u=function(e,t,s){const r=[];let n,i,l=e.length;for(r[s]=e[e.length-1],r[0]=e[0],n=1;n<s;n++)i=s-n+1,r[i-1]=e[t[l-1][i-1]-2],l=t[l-1][i-1]-1;return r}(e,o.lower_class_limits,n);return null!==i&&(u=s(u,i)),l||(u=u.slice(1,-1)),u}function w(e){let s=e.filter((e=>t(e))).map((e=>+e));return s.reduce(((e,t)=>+e+ +t),0)/s.length}function g(e){let s=e.filter((e=>t(e))).map((e=>+e)),r=w(s);return 1*function(e){return e.filter((e=>t(e))).map((e=>+e)).reduce(((e,t)=>+e+ +t),0)}(s.map((e=>(e-r)**2)))/(s.length-1)}function v(e){return Math.sqrt(g(e))}function x(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=t(r.k)?r.k:1,i=!1!==r.middle&&null!=r.middle,l=f(r.precision),a=!0===r.minmax||null==r.minmax;const o=b(e),u=d(e),h=w(e),c=v(e);let m=[o,u];if(1==i){let e=h+n/2*c;for(;e<u;)m.push(e),e+=c*n;for(e=h-n/2*c;e>o;)m.push(e),e-=c*n}else{m.push(h);let e=h+c*n;for(;e<u;)m.push(e),e+=c*n;for(e=h-c*n;e>b;)m.push(e),e-=c*n}return m=m.sort(((e,t)=>e-t)),null!==l&&(m=s(m,l)),a||(m=m.slice(1,-1)),m}function y(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=null!=r.nb?c(r.nb):5,i=f(r.precision),o=!0===r.minmax||null==r.minmax;if(n>e.length)throw new a;if(e.some((e=>e<=0)))throw new l;let u=new Array(n+1);const h=b(e),m=d(e),p=Math.log(m)/Math.LN10,_=Math.log(h)/Math.LN10,k=(p-_)/n;u[0]=h;for(let e=1;e<n;e++)u[e]=Math.pow(10,_+e*k);return u[n]=m,u=u.sort(((e,t)=>e-t)),null!==i&&(u=s(u,i)),o||(u=u.slice(1,-1)),u}function M(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=null!=r.nb?c(r.nb):5,i=f(r.precision),l=!0===r.minmax||null==r.minmax;if(n>e.length)throw new a;let o=[],u=0;for(let e=0;e<=n;e++)u+=e;let h=b(e),m=d(e),p=(m-h)/u;for(let e=0;e<=n;e++)o[e]=0===e?h:e===n?m:o[e-1]+e*p;return null!==i&&(o=s(o,i)),l||(o=o.slice(1,-1)),o}function E(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=null!=r.nb?c(r.nb):5,i=f(r.precision),l=!0===r.minmax||null==r.minmax,a=[b(e)];if(function e(t){const s=w(t);a.push(s);const r=t.filter((e=>e>s));for(;r.length>1&&r.length/t.length<=.4;)return e(r)}(e),n&&null!==n){n-a.length<0&&a.splice(n)}return a.push(d(e)),null!==i&&(a=s(a,i)),l||(a=a.slice(1,-1)),a}function C(e,t=!0){let s,r=Math.floor(Math.log10(e)),n=e/Math.pow(10,r);return s=t?n<1.5?1:n<3?2:n<7?5:10:n<=1?1:n<=2?2:n<=5?5:10,s*10**r}function q(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));const n=f(r.precision),i=!0===r.minmax||null==r.minmax,l=null!=r.nb?c(r.nb):5;if(l>e.length)throw new a;const o=b(e),u=d(e),h=C(u-o,!1),m=C(h/(l-1),!0);let p=function(e,t,s=1){const r=[];let n=0;for(;e<t;)r[n++]=e,e+=s;return r}(Math.floor(o/m)*m,Math.ceil(u/m)*m+.5*m,m);return null!==n&&(p=s(p,n)),i||(p=p.slice(1,-1)),p}function T(e,r={}){e=e.filter((e=>t(e))).map((e=>+e));let n=null!=r.nb?c(r.nb):4;if(!(i=n)||0===i||0!=(i&i-1))throw new u("The 'nb' parameter must be a power of 2");var i;let l=f(r.precision),o=!0===r.minmax||null==r.minmax;if(n>e.length)throw new a;let h=[],m=[b(e),d(e)],p=t=>w(e.filter((e=>e>=t[0]&&e<=t[1])));for(;h.length+1<n;){let e=[m[0],...h,m[1]].reduce(((e,t,s,r)=>(s<r.length-1&&e.push([r[s],r[s+1]]),e)),[]);h=h.concat(e.map((e=>p(e)))).sort(((e,t)=>e-t))}let _=h.sort(((e,t)=>e-t));return o&&(_=[m[0],..._,m[1]]),null!==l&&(_=s(_,l)),_}class I{constructor(e,t){if(this.constructor===I)throw new TypeError('Abstract class "AbstractClassifier" cannot be instantiated directly.');this._values=e,this.precision=f(t),this.type=null,this.nClasses=null,this._breaks=null,this._min=null,this._max=null,this._mean=null,this._median=null,this._stddev=null,this._counts=null,this._splitValues=null}get values(){return this._values}set values(e){this._values=e,this._min=null,this._max=null,this._mean=null,this._median=null,this._stddev=null,this._counts=null,this._breaks=null,this.nClasses=null}get breaks(){return this._breaks}set breaks(e){this._breaks=e,this.nClasses=e.length-1,this._counts=null}min(){return null===this._min?(this._min=b(this._values),this._min):this._min}max(){return null===this._max?(this._max=d(this._values),this._max):this._max}mean(){return null===this._mean?(this._mean=w(this._values),this._mean):this._mean}median(){return null===this._median?(this._median=function(e){let s=e.filter((e=>t(e))).map((e=>+e)).sort(((e,t)=>e-t)),r=Math.floor(s.length/2);return s.length%2!=0?s[r]:(s[r-1]+s[r])/2}(this._values),this._median):this._median}stddev(){return null===this._stddev?(this._stddev=v(this._values),this._stddev):this._stddev}population(){return this._values.length}countByClass(){if(null===this._breaks)throw new Error('Breaks are not set, please call the "classify" method first');if(null===this._counts){const e=new Array(this.nClasses).fill(0);for(let t=0;t<this._values.length;t++){const s=this._values[t];e[this.getClass(s)]++}this._counts=e}return this._counts}splitByClass(){if(null===this._breaks)throw new Error('Breaks are not set, please call the "classify" method first');if(null===this._splitValues){const e=this._values.slice().sort(((e,t)=>e-t));this._splitValues=this._breaks.slice(1).map(((t,s)=>e.filter((e=>e<=t&&e>(0===s?-1/0:this._breaks[s])))))}return this._splitValues}getClass(e){if(null===this._breaks)throw new Error('Breaks are not set, please call the "classify" method first');for(let t=0,s=this._breaks.length;t<s;t++)if(e<=this._breaks[t+1])return t;return this.nClasses}classify(){throw new Error('Method "classify" is not implemented')}}e.ArithmeticProgressionClassifier=class extends I{constructor(e,t){super(e,t),this.type="arithmetic"}classify(e){return this.breaks=M(this._values,{nb:e,precision:this.precision}),this._breaks}},e.CustomBreaksClassifier=class extends I{constructor(e,t,s){super(e,t),this.type="custom",s&&(this.breaks=s)}classify(e){return this.breaks=e,this._breaks}},e.EqualClassifier=class extends I{constructor(e,t){super(e,t),this.type="equal"}classify(e){return this.breaks=_(this._values,{nb:e,precision:this.precision}),this._breaks}},e.GeometricProgressionClassifier=class extends I{constructor(e,t){super(e,t),this.type="geometric"}classify(e){return this.breaks=y(this._values,{nb:e,precision:this.precision}),this._breaks}},e.HeadTailClassifier=class extends I{constructor(e,t){super(e,t),this.type="headtail"}classify(e){return this.breaks=E(this._values,{nb:e,precision:this.precision}),this._breaks}},e.InvalidNumberOfClassesError=u,e.InvalidPrecisionError=h,e.JenksClassifier=class extends I{constructor(e,t){super(e,t),this.type="jenks"}classify(e){return this.breaks=k(this._values,{nb:e,precision:this.precision}),this._breaks}},e.MsdClassifier=class extends I{constructor(e,t){super(e,t),this.type="msd"}classify(e=1,t=!0){return this.breaks=x(this._values,{precision:this.precision,middle:t,k:e}),this._breaks}},e.NestedMeansClassifier=class extends I{constructor(e,t){super(e,t),this.type="nested-means"}classify(e){return this.breaks=T(this._values,{nb:e,precision:this.precision}),this._breaks}},e.PrettyBreaksClassifier=class extends I{constructor(e,t){super(e,t),this.type="pretty"}classify(e){return this.breaks=q(this._values,{nb:e,precision:this.precision}),this._breaks}},e.Q6Classifier=class extends I{constructor(e,t){super(e,t),this.type="q6"}classify(){return this.breaks=m(this._values,{precision:this.precision}),this._breaks}},e.QuantileClassifier=class extends I{constructor(e,t){super(e,t),this.type="jenks"}classify(e){return this.breaks=p(this._values,{nb:e,precision:this.precision}),this._breaks}},e.TooFewValuesError=a,e.UnknownMethodError=o,e.ValuesInferiorOrEqualToZeroError=l,e.arithmeticProgression=M,e.breaks=function(e,t={}){let s;switch(t.method?t.method:"quantile"){case"q6":s=m(e,t);break;case"quantile":s=p(e,t);break;case"equal":s=_(e,t);break;case"jenks":s=k(e,t);break;case"msd":s=x(e,t);break;case"geometric":s=y(e,t);break;case"headtail":s=E(e,t);break;case"pretty":s=q(e,t);break;case"arithmetic":s=M(e,t);break;case"nestedmeans":s=T(e,t);break;default:throw new o}return s},e.equal=_,e.geometricProgression=y,e.headtail=E,e.jenks=k,e.msd=x,e.nestedMeans=T,e.pretty=q,e.q6=m,e.quantile=p,Object.defineProperty(e,"__esModule",{value:!0})}));
